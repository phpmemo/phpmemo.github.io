---
layout: note
title: "Знак равенства (=) в PHP — это оператор присваивания"
card_id: 10
date: 2025-09-16
card_type: theory # theory, technique, practice
categories: ["PHP Basics"]
difficulty: 1 # Уровень сложности (опционально)
icon: book # book, lightning-bolt, check-circle (соответствует типу)
question: |
  Расскажите об использовании символа `=` (знак равенства) в PHP.

short_answer: |
  Знак `=` в PHP — это оператор присваивания (а не сравнения!). Он заносит значение из правой части в переменную слева. Возвращает присвоенное значение, что позволяет писать `$a = $b = 0`.
  Имеет комбинированные формы (`+=`, `.=`). Отличается от `==` (равно) и `===` (тождественно равно). Присваивание по ссылке делается оператором `=&`.
---
### 1. Основное назначение: Оператор присваивания

Его главная задача — присвоить значение, находящееся справа, переменной или элементу массива, находящемуся слева.

```php
$variable = 'value'; // Присвоить строку 'value' переменной $variable
$array[0] = 100;     // Присвоить значение 100 элементу массива с индексом 0
$object->property = new Class(); // Присвоить свойству объекта
```

### 2. Присваивание по ссылке

С помощью амперсанда (`&`) оператор `=` выполняет присваивание не значения, а ссылки на ту же область памяти, что и другая переменная. Изменение одной переменной будет влиять на другую.

```php
$a = 10;
$b = &$a; // $b — это ссылка на $a, а не копия значения

$b = 20;
echo $a; // Выведет 20, потому что менялась ячейка памяти, на которую ссылаются и $a, и $b
```
**Суть:** Он создает не две независимые переменные, а две ссылки на одну и ту же область памяти. Изменение одной переменной немедленно отражается на другой.

Это может использоваться **в циклах (для работы с исходными элементами массива)**:
```php
$array = [1, 2, 3];
foreach ($array as &$value) { // & — ссылка на элемент массива
    $value *= 2; // Изменяем оригинальный элемент
}
unset($value); // Важно! Разрываем ссылку после цикла
print_r($array); // [2, 4, 6]
```

**Важная особенность (ловушка):** После использования `&` в цикле `foreach` ссылка остается на последний элемент массива. Чтобы избежать ошибок, необходимо вызывать `unset()` для переменной-ссылки после цикла.

### 3. Комбинированные операторы присваивания

`=` комбинируется с арифметическими и строковыми операторами для сокращенной записи.

```php
$a = 10;
$a += 5;   // Эквивалентно $a = $a + 5;   -> $a = 15
$a .= 'px'; // Эквивалентно $a = $a . 'px'; -> $a = '15px'
```
Другие примеры: `-=`, `*=`, `/=`, `%=`, `**=`, `&=`, `|=`, `^=`, `<<=`, `>>=`.

### 4. Присваивание в условии и возвращаемое значение

Важная особенность: оператор присваивания **возвращает значение**, которое было присвоено. Это позволяет делать множественное присваивание, но также является частым источником ошибок, когда `=` путают с `==`.

```php
$a = $b = $c = 100; // Всем трем переменным присваивается 100

// ОПАСНАЯ ОШИБКА (из-за возвращаемого значения):
if ($value = getUserID()) { // Присваивание, а не сравнение!
    // Код всегда выполнится, если getUserID() не вернет false или null.
    // Значение $value будет приведено к булеву типу.
}
// Правильное сравнение:
if ($value == getUserID()) { ... }
```

### 5. Отличие от операторов сравнения

Это критически важное отличие для понимания синтаксиса PHP.

*   **`=`** — **Оператор присваивания.** Присваивает значение.
    `$x = 5;` — "Записать в `$x` число 5".

*   **`==`** — **Оператор равенства.** Проверяет, равны ли значения после приведения типов.
    `$x == 5` — "Значение в `$x` равно 5?" (например, `5 == '5'` будет `true`).

*   **`===`** — **Оператор тождественного равенства.** Проверяет, что значения и их типы одинаковы.
    `$x === 5` — "Значение в `$x` равно 5 И является целым числом?" (например, `5 === '5'` будет `false`).

### 6. Присваивание при передаче аргументов в функцию

По умолчанию аргументы в функцию передаются **по значению** (создается копия). Однако с помощью оператора `=&` в объявлении функции можно заставить параметр принимать аргумент **по ссылке**.

```php
function modify(&$param) { // & + параметр
    $param = 'changed';
}

$var = 'original';
modify($var); // Передача по ссылке
echo $var; // Выведет 'changed'
```

**Если функция специально предназначена для работы по ссылке:**
Она должна возвращать **ссылку**. Для этого в объявлении функции используется `&`.

```php
function &get_reference() {
    $value = 10;
    return $value; // ВНИМАНИЕ: Возврат ссылки на локальную переменную - ОПАСНО!
}
// Теперь можно (но не нужно в таком виде):
$var = &get_reference();
```
**Важно:** Возврат ссылки на локальную переменную функции (`$value`) — это **опасное действие**, так как переменная уничтожается после завершения функции, и ссылка становится недействительной (dangling reference). Так делают только в очень специфических случаях, когда возвращают ссылку на свойство объекта или элемент статического массива.

**Правильный пример:**
```php
class Container {
    public $value = 10;
}

function &getReference(Container $obj) {
    return $obj->value; // Возвращаем ссылку на свойство объекта
}

$container = new Container();
$var = &getReference($container); // Теперь $var - ссылка на $container->value
$var = 20;
echo $container->value; // 20
```

### Итог:

Знак `=` в PHP — это **оператор присваивания**. Его ключевые особенности:
1.  **Присваивает значение** переменной, элементу массива или свойству объекта.
2.  **Возвращает присвоенное значение**, что позволяет делать цепочки присваивания (`$a = $b = 0`), но является частой причиной ошибок в условиях.
3.  **Работает по значению** (создает копию) или **по ссылке** (с использованием `&`).
4.  Имеет **комбинированные формы** (`+=`, `.=` и др.) для сокращения записи.
5.  **Принципиально отличается** от операторов сравнения `==` (равно) и `===` (тождественно равно). Путаница между `=` и `==` — классическая ошибка новичков.
